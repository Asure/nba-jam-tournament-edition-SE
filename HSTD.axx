	.file	"hstd.asm"
	.title	"robo high-score-to-date management"
	.width	132
	.option	b,d,l,t
	.mnolist

	.include	"mproc.equ"
	.include	"disp.equ"
	.include	"sys.equ"
	.include	"game.equ"
	.include	"imgtbl.glo"
	.include	"link.equ"
	.include	"shawn.hdr"		;Macros


	.TEXT


	.DEF	GET_HSCR
	.DEF	RC_BYTEI
	.DEF	RC_BYTE
	.DEF	RC_WORD
	.DEF	RC_LONG
	.DEF	RC_LONGI
	.DEF	WC_BYTE
	.DEF	WC_BYTEI
	.DEF	WC_WORD
	.DEF	WC_WORDI
	.DEF	WC_LONG
	.DEF	WC_LONGI
	.DEF	PT_ENTRY
	.DEF	INIT_TB
	.DEF	INIT_TAB	;GEORGES POWER UP ENTRY
	.DEF	P_FORK
	.DEF	VAL_TAB
	.DEF	ROM_PTRS


	.DEF	ISHSTD,GETINIT,GETINIT1,GETINIT2,INITTIM
	.DEF	SET_PAGE
	.DEF	A2_CHECK
	.DEF	DEC_HSR,INIT_HSR,GET_HSC
	.DEF	GETHIGH	
	.def	INITMAT


	.REF	RD15FONT,SYSCOPY,P1DATA,P2DATA
	.REF	BINBCD,FON150



	 .REF	DEF_PAGE,GET_ADJ


	 .TEXT


BEEPSND	 .WORD	0F3FEH,010H,080A2H,0		;LOW BEEP



 .if 0	
ALL_TAB
	.LONG	ALL_TIME_ORIGIN 	;LOCATION OF TABLE
	.WORD	ALL_TIME_ENTRIES-1	;NUMBER IN THE TABLE (DON'T COUNT ZERO FILLER)
	.WORD	ALL_TIME_VISIBLE	;# VISIBLE (SHOW 20 ALL TIME)
	.WORD	ALL_TIME_SELECT 	;BITS TO SELECT IT
	.LONG	ALL_TIME_ROM_TABLE	;ROM IMAGE OF TABLE
	.WORD	ALL_TIME_ENTRIES/5	;RESET TABLE IF 1/5 OR MORE BAD

TOD_TAB
	.LONG	TODAYS_ORIGIN		;LOCATION OF TABLE
	.WORD	TODAYS_ENTRIES-1	;NUMBER IN THE TABLE (DON'T COUNT ZERO FILLER)
	.WORD	TODAYS_VISIBLE		;# VISIBLE (SHOW 20 ALL TIME)
	.WORD	TODAYS_SELECT		;BITS TO SELECT IT
	.LONG	TODAYS_ROM_TABLE	;ROM IMAGE OF TABLE
	.WORD	TODAYS_ENTRIES/5	;RESET TABLE IF 1/5 OR MORE BAD
 .endif

P_FORK
	MMTM	SP,A1
	MOVE	*A13(PROCID),A1		;PASS OUR ID TO FORKED PROCESS
	CALLA	GETPRC			;MAKE THE PROCESS
	MMFM	SP,A1
	RETS

DEC_HSR
	MMTM	SP,A0
	CALLR	GET_HSC 	;THIS IS EASY...GET THE COUNTER
	JRZ	DECHX		;ITS ZERO....NO ACTION.
	DEC	A0		;REMOVE A TICK
	CALLR	PUT_HSC 	;PUT IT BACK JAK
DECHX	MMFM	SP,A0
	RETS

HS_MIN	 EQU	 750		 ;ALWAYS 750 PLAYS BEFORE REMOVING A FRESH
DELAY_HSRESET:
	MMTM	SP,A0
	CALLR	GET_HSC 	;THIS IS EASY...GET THE COUNTER
	CMPI	HS_MIN,A0	;IS IT TOO LOW
	JRHS	DHX		;NOPE...NO ACTION

	MOVI	HS_MIN,A0	;STOP THE RESET!
	CALLR	PUT_HSC 	;THIS MANY PLAYS TILL RESET!
DHX:	
	MMFM	SP,A0
	RETS
	
INIT_HSR
	MMTM	SP,A0
	MOVI	ADJHSRES,A0
	CALLA	GET_ADJ 	;GET THE ADJUSTED VALUE
	CALLR	PUT_HSC 	;SET IT TO THIS VALUE
	MMFM	SP,A0
	RETS

PUT_HSC
	MMTM	SP,A7,A0
	CALLR	HSR_PAGE		;HIGH SCORE PAGE

	MOVI	HRESET_COUNTER,A7	;POINT AT
	CALLR	WC_LONGI		;WRITE OUR PARAMETER
	NOT	A0			;NEGATE IT.
	CALLR	WC_LONG 		;AND WRITE IN SUBSEQUENT SPOT.
	CALLA	DEF_PAGE		;FLIP PAGE
	MMFM	SP,A7,A0		;AND RETURN
	RETS

GET_HSC
	MMTM	SP,A7,A1
	CALLR	HSR_PAGE		;POINT PAGE AT HSR

	MOVI	HRESET_COUNTER,A7	;POINT AT
	CALLR	RC_LONGI		;READ THE VALUE
	MOVE	A0,A1			;STASH IT
	CALLR	RC_LONG 		;READ VERIFIER
	NOT	A0			;SEE IF ITS VALID
	CMP	A0,A1
	JRZ	GET_HSCX		;IT IS....RETURN IT.

	CALLR	INIT_HSR		;REFRESH IT WITH FACTORY VALUE
	MOVI	ADJHSRES,A0
	CALLA	GET_ADJ 		;GET THE ADJUSTED VALUE

GET_HSCX
	CALLA	DEF_PAGE		;FLIP PAGE AWAY FROM US
	MOVE	A0,A0			;SET Z FLAG BASED ON COUNTER
	MMFM	SP,A7,A1
	RETS

HSR_PAGE
	MMTM	SP,A1
	MOVI	HSR_SELECT,A1
	CALLR	SET_PAGE
	MMFM	SP,A1
	RETS

GETHIGH
 .if 0
	movi	ALL_TIME_SELECT,a1
	callr	SET_PAGE

	movi	[62,27],a10				;Screen start address
	movi	ALL_TIME_ORIGIN+HS_INITS+HS_SIZE,a8	;Table start address
	JSRP	HSINITDSP

	movi	[62,63],a10
	movi	ALL_TIME_ORIGIN+HS_SCORE+HS_SIZE,a8
	JSRP	HSNUMDSP

	movi	TODAYS_SELECT,a1
	CALLR	SET_PAGE

	movi	[62,227],a10
	movi	TODAYS_ORIGIN+HS_INITS+HS_SIZE,a8
	JSRP	HSINITDSP

	movi	[62,263],a10
	movi	TODAYS_ORIGIN+HS_SCORE+HS_SIZE,a8
	JSRP	HSNUMDSP
 .endif
	RETP



HSNUMDSP
	movk	10,a11			;# scores
	movi	01010101H,a9		;Start color 1, pal 1

hsn10	move	a8,a7
	callr	RC_LONG			;GET THE SCORE=A0
	move	a7,a8
	move	a10,a3			;Dest Y:X
	clr	a6			;Blanking ON
	move	a12,-*sp,L
	movk	8,a12
	callr	HSNUML0
	move	*sp+,a12,L
	SLEEPK	1
	addi	HS_SIZE,a8
	addi	0120000H,a10		;Next line
	dsj	a11,hsn10

	RETP


HSNUML0
	mmtm	sp,a2,a3,a4,a5,a7,a8,a10,a11

	move	a0,a11
	srl	4*3,a0
	jrz	hsnlp			;No comma?
	subk	6,a3			;-X

hsnlp	move	a11,a1
	srl	28,a1			;Next digit value into lowest 4 bits
	jrnz	hsn5
	move	a6,a6
	jrz	hsn50			;Skip digit if blanking

hsn5	cmpi	3,a12
	jrnz	hsn13
	move	a6,a6
	jrz	hsn13			;1st non zero?
	move	a1,-*sp
	movi	RD15FONT+11*32,a1	;Comma
	move	*a1,a1,L
	move	a3,a10
	addi	0b0000H,a3		;+Y
	callr	font_dma
	move	a10,a3
	addk	6,a3			;+X
	move	*sp+,a1

hsn13	cmpi	9,a1
	jrls	hsn15			;Digit ok?
	movk	9,a1			;Output 9 on an error

hsn15	movk	1,a6			;Blanks off
	move	a3,a10
	cmpi	1,a1
	jrnz	hsn30
	addk	3,a3			;Offset 1's X
hsn30	movi	32*4+16,a0
	mpyu	a0,a1			;*Header size
	addi	FON150,a1		;Base address of image header
	callr	font_dma
	move	a10,a3

hsn50	addk	14,a3			;step to next
	sll	4,a11			;next digit
	dsj	a12,hsnlp

	addi	0f0f0000H,a9
	cmpi	030300000H,a9
	jrls	hsnx
	addi	0101H,a9			;Next PAL
	zext	a9
	addi	01010000H,a9		;Color 1

hsnx	mmfm	sp,a2,a3,a4,a5,a7,a8,a10,a11
	rets



font_dma
	move	*a1(ISAG),a4,L
	move	*a1(ICTRL),a5
	move	*a1+,a2			;Get X size
	move	a5,a7
	sll	32-15,a7		;Get bits 12-14
	srl	32-15+12,a7
	mpyu	a2,a7

	addi	010000H,a2		;Y Size 1
	move	*a1+,a8			;Get Y size

	ori	DMACNZ,a5
	move	a9,a1
fdlp	calla	QDMAN
	addi	01010000H,a1		;Next color
	add	a7,a4			;Set SAG for next line
	addi	010000H,a3		;Y+1
	dsj	a8,fdlp

	rets



HSINITDSP
	movk	10,a11			;10 Scores

hsid10	move	a8,a7
	subi	HS_INITS,a7
	callr	RC_LONG 		;Get the score in a0
	move	a0,a2
	addi	HS_INITS,a7
	move	a10,a3			;Y:X

	movi	001010101H,a1		;Flash if inits match score
	callr	A2_CHECK
	jrz	hsid30
	movi	01f1f0303H,a1		;Color:pal

hsid30	move	a12,-*sp,L
	movk	3,a12

hsid50	callr	RC_BYTE			;Get initial
	addk	16,a7			;Step to next initial
	callr	initout			;Output initial
	dsj	a12,hsid50

	move	*sp+,a12,L
	addi	0120000H,a10		;Next Y
	move	a7,a8
	SLEEPK	1
	addi	HS_SIZE-48,a8		;Get next guy in cmos
	dsj	a11,hsid10

	RETP


initout
	mmtm	sp,a1,a2,a4,a5,a7,a8,a9,a10,a11,a14

	subi	021H,a0			;Start of table
	cmpi	07dH-021H,a0
	jrhi	inox

	sll	5,a0
	addi	RD15FONT,a0
	move	*a0,a0,L		;Get pointer
	move	*a0(ISAG),a4,L
	move	*a0(ICTRL),a5
	move	*a0+,a2			;Get X size

	move	a5,a7
	sll	32-15,a7		;Get bits 12-14
	srl	32-15+12,a7
	mpyu	a2,a7


	movk	12,a9
	sub	a2,a9
	sra	1,a9			;/2
	add	a9,a3			;Add X offset so letter centered

	addi	010000H,a2		;Y Size 1
	move	*a0+,a8			;Get Y size
	clr	a11			;A11=Line cnt

	move	a3,a10
	ori	DMACNZ,a5
inolp	calla	QDMAN
	addk	1,a11
	cmpi	15,a11
	jrge	ino50			;Out of colors?
	addi	01010000H,a1		;Next color
ino50	add	a7,a4			;Set SAG for next line
	addi	010000H,a3		;Y+1
	dsj	a8,inolp

	move	a10,a3
	sub	a9,a3
inox	addk	17,a3

	mmfm	sp,a1,a2,a4,a5,a7,a8,a9,a10,a11,a14
	rets


INITOUT
	PUSH	a2,a4,a5,a14

	subi	021H,a0			;Start of table
	cmpi	07dH-021H,a0
	jrhi	initerr

	sll	5,a0
	addi	RD15FONT,a0
	move	*a0,a0,L		;Get pointer
	move	*a0,a2,L		;Get size
	movk	12,a4
	subxy	a2,a4
	sext	a4
	sra	1,a4			;/2
	add	a4,a3			;Add X offset so letter centered
	move	a4,-*sp
	move	*a0(ISAG),a4,L
	move	*a0(ICTRL),a5
	ori	DMACNZ,a5
	calla	QDMAN
	move	*sp+,a0
	sub	a0,a3
initerr	addk	17,a3

	PULL	a2,a4,a5,a14
	rets



ISHSTD

 .if 0
	MMTM	SP,A8,A10
	MOVK	1,A0
	MOVE	@P1DATA,A8,L		;FIX!
	MOVE	@P2DATA,A10,L

	CALLR	CHECK_ALL_TIME
	JRNZ	ISHSTD1

	CALLR	CHECK_TODAY
	JRNZ	ISHSTD1
	CLR	A0
ISHSTD1	
	SWAP	A8,A10
	ADDK	2,A0
	CALLR	CHECK_ALL_TIME
	JRNZ	VERY_HIGH

	CALLR	CHECK_TODAY
	JRNZ	VERY_HIGH
	SUBK	2,A0
VERY_HIGH
	MMFM	SP,A8,A10
	RETS

CHECK_ALL_TIME
	MMTM	SP,A0,A2,A8
	MOVE	A8,A0
	MOVE	A10,A2				;SHOW "OTHER" SCORE IN A2
	MOVI	ALL_TAB,A8
	CALLR	CHECK_SCORE		
	MMFM	SP,A0,A2,A8
	RETS

CHECK_TODAY
	MMTM	SP,A0,A2,A8		
	MOVE	A10,A2				;SHOW "OTHER" SCORE IN A2
	MOVE	A8,A0
	MOVI	TOD_TAB,A8
	CALLR	CHECK_SCORE		
	MMFM	SP,A0,A2,A8		
	RETS
 .endif


	.BSS	INITTIMR,16
	.BSS	GET1FLG,16
	.BSS	GET2FLG,16

INITTIM
	CLR	A0
	MOVE	A0,@GET1FLG
	MOVE	A0,@GET2FLG
	CREATE	HISC_PID,INTIML
	MOVI	30,A1
	MOVE	A1,@INITTIMR
	MOVE	A1,*A0(PA10),L		;SET A10 TO 60
	RETS

INTIML
	MOVE	@INITTIMR,A0
	DEC	A10
	JRNE	INTIML1
	MOVI	60,A10
	DEC	A0
	JRN	INITTIMX
	MOVE	A0,@INITTIMR

INTIML1	CALLA	BINBCD
	MOVI	[19,194],A3
	MOVE	A12,-*SP,L
	MOVK	2,A12
	MOVK	1,A6
	SLL	24,A0			;SHIFT DIGITS INTO PLACE
	movi	01010101H,a9
	callr	HSNUML0
	MOVE	*SP+,A12,L
	SLOOP	1,INTIML
INITTIMX
	DIE


GETINIT
	SLEEPK	10
	CALLR	DONCK
	JRNE	GETINIT
GETINITX
	SLEEP	60		;WAIT A SEC. THEN BOOK
	RETP


DONCK
	MOVE	@INITTIMR,A2
	JREQ	DONCKX
	MOVE	@GET1FLG,A0
	MOVE	@GET2FLG,A1
	ADD	A0,A1
DONCKX	RETS


GETINIT1


GETINIT2


 .if 0
GTINIT
	MOVE	A13,A8
	ADDI	PDATA,A8
	MOVE	*A0+,A1,L	
	MOVE	*A1+,*A8+,L	;PUT THE SCORE
	MOVK	8,A1

GTI0L	MOVE	*A0+,A3,L
	MOVE	A3,*A8+,L
	DSJS	A1,GTI0L
	MOVK	1,A1
	MOVE	A1,*A3,W	;INCREMENT DONE FLAG
	CLR	A11		;CURRENT INITIAL WORKING ON
	CLR	A10		;JOYSTICK DEBOUNCE TIMER
	CLR	A9		;FIRE/START DEBOUNCE


	CLR	A0			;A0=OXVAL
	CLR	A1			;A1=OYVAL
	MOVI	9EH,A3			;(OZPOS)
	MOVI	DMAWNZ,A4		;(OFLAGS) NON-ZERO VALUE
	clr	a5			;(OID)
	CLR	A6			;(OXVEL)
	CLR	A7			;(OYVEL)
	CALLA	BEGINOBJ

GTL	CMPI	3,A11			;GET MOVE SWITCHES
	JRHS	GTL4				;ENTERED 'EM ALL 

	CALLR	DONCK
	JRNE	GTL0
	
	MOVI	3,A11				;TIMES UP STUFF EM IN
	JRUC	GTL3X
GTL0	MOVE	*A13(PDATA+060H),A0,L		;GET MOVE SWITCH ADDRESS
	MOVE	*A0,A1,W
	NOT	A1
	SLL	28,A1
	SRL	28,A1
	JRNE	GTL1
	CLR	A10				;CLEAR DEBOUNCE TIMER
	JRUC	GTL5
GTL1	MOVE	A10,A10
	JRNE	GTL5
	MOVK	12,A10
	SLL	4,A1
	ADDI	IJOYTAB,A1
	MOVB	*A1,A0				;GET DX
	MOVB	*A1(8),A1			;GET DY
	MOVE	*A13(PDATA+040H),A2		;GET X COORD
	MOVE	*A13(PDATA+050H),A3		;GET Y COORD
	ADD	A2,A0				;ADD DX, CHECK LIMITS
	JRNN	GM1
	CLR	A0
GM1	CMPI	5,A0
	JRLS	GM2
	MOVK	5,A0
GM2	ADD	A3,A1				;ADD DY CHECK LIMITS
	JRNN	GM3
	CLR	A1
GM3	CMPI	4,A1
	JRLS	GM4
	MOVK	4,A1
GM4	MOVE	A0,*A13(PDATA+040H)		;SAVE COORDS
	MOVE	A1,*A13(PDATA+050H)


GTL5	MOVE	*A13(PDATA+040H),A0		;Get X
	MOVE	*A13(PDATA+050H),A1		;Get Y
	movk	21,a3
	movk	22,a5
	MPYU	A0,A3				;FORM X OFFSET
	MPYU	A1,A5				;FORM Y OFFSET
	move	@WORLDTLX+16,a2
	add	a2,a3
	addi	137,a3
	move	@WORLDTLY+16,a2
	add	a2,a5
	addi	41,a5
	MOVE	A3,*A8(OXPOS)			;UPDATE POSITION
	MOVE	A5,*A8(OYPOS)

	MOVK	6,A3
	MPYU	A1,A3
	ADD	A0,A3				;THIS IS THE INDEX TO MATRIX
	SLL	3,A3
	ADDI	INITMAT,A3
	MOVB	*A3,A0
	MOVE	A11,A4
	SLL	3,A4
	ADD	A13,A4
	ADDI	PDATA+020H,A4
	MOVB	A0,*A4				;STORE OUT CURRENT INITIAL

	MOVE	*A13(PDATA+0A0H),A1,L	
	MOVE	*A1,A1,W
	NOT	A1
	SLL	31,A1
	JRNE	GTL3
	CLR	A9				;CLEAR DEBOUNCE TIMER
	JRUC	GTL4
GTL3
	MOVE	A9,A9				;DEBOUNCE STILL ON
	JRNE	GTL4
	MOVI	120,A9

	MOVB	*A4,A0				;CHECK FOR RUB DUDES...
	CMPI	03CH,A0
	JRNE	GTL3A				;NO....
	DEC	A11
	JRNN	GTL30
	CLR	A11				;CAN'T RUB FIRST CHAR
	JRUC	GTL4
GTL30
	MOVI	BEEPSND,A0
	CALLA	snd_play1
	MOVK	020H,A0
	MOVB	A0,*A4				;THROW OUT A SPACE
	JRUC	GTL4
GTL3A
	MOVI	BEEPSND,A0
	CALLA	snd_play1
	INC	A11
	CMPI	3,A11
	JRLO	GTL4
GTL3X
	CALLA	DELOBJA8
	MOVE	*A13(PDATA+0100H),A0,L
	CLR	A1
	MOVE	A1,*A0				;CLEAR DONE FLAG
	CALLR	GTX				;UPDATE TABLE ENTRY

GTL4
	MOVE	A13,A2				;GET INITIAL STORE ADDRESS

	ADDI	PDATA+020H,A2
	MOVK	3,A1				;DO THREE INITIALS
	MOVE	*A13(PDATA+0C0H),A3,L		;GET BASE SCREEN ADDRESS
GTL5L
	MOVB	*A2,A0
	MMTM	SP,A1,A2,A3
	MOVE	*A13(PDATA+0E0H),A1,L		;GET COLOR:PALETTE
	CALLR	INITOUT
	MMFM	SP,A1,A2,A3
	ADDK	016H,A3				;INC SCREEN COORD
	ADDK	8,A2				;INC DISPLAY ADDRESS
	DSJS	A1,GTL5L
	MOVE	A10,A10				;DEC TIMER ?
	JREQ	GTL6				;NO, ALREADY ZERO
	DEC	A10				;DEC IT
GTL6
	MOVE	A9,A9				;DEC TIMER ?
	JREQ	GTL7				;NO, ALREADY ZERO
	DEC	A9				;DEC IT
GTL7
	SLEEPK	1
	JRUC	GTL
GTX
	MOVE	*A13(PDATA),A0,L		;GET SCORE POINTS
	MOVE	A13,A1
	ADDI	PDATA+020H,A1			;POINT TO INITIAL STORAGE
	MOVI	 TOD_TAB,A8			;ALWAYS ADD TO TODAYS (EVEN IF SPACES)
	CALLR	 ADD_ENTRY			;ADD EM TO THIS ONE IF NEC.

	MOVI	 ALL_TAB,A8
	CALLR	 ADD_ENTRY			;ADD EM TO THE TABLE
	JRC	 TOO_BAD			;DIDN'T MAKE ALL TIME

	CALLR	 DELAY_HSRESET			;NEW ENTRY....DON'T RESET TOO QUICK

TOO_BAD	RETS
 .endif

				;RLDU
	
IJOYTAB
	.BYTE	0,0		;0000
	.BYTE	0,-1		;0001
	.BYTE	0,1		;0010
	.BYTE	0,0		;0011
	.BYTE	-1,0		;0100
	.BYTE	-1,-1		;0101
	.BYTE	-1,1		;0110
	.BYTE	-1,0		;0111
	.BYTE	1,0		;1000
	.BYTE	1,-1		;1001
	.BYTE	1,1		;1010
	.BYTE	1,0		;1011
	.BYTE	0,0		;1100
	.BYTE	0,-1		;1101
	.BYTE	0,1		;1110
	.BYTE	0,0		;1111


INITMAT	.STRING	"ABCDEFGHIJKLMNOPQRSTUVWXYZ!? <"

A2_CHECK
	MMTM	SP,A0
	MOVE	@P1DATA,A0,L		;FIX!
	CMP	A2,A0
	JREQ	A2_SUCC 		;IT WAS PLAYER 1'S SCORE

	MOVE	@P2DATA,A0,L
	CMP	A2,A0

A2_SUCC	MMFM	SP,A0
	RETS

CHECK_INITS:
	MMTM	SP,A0,A1,A2
	MOVI	NUM_INITS,A2
CHECK_NEXT:
	MOVB	*A1,A0			;GET AN INITIAL
	JRZ	SPACE_FOUND		;NULL IS A SPACE
	CMPI	SPACE,A0		;IS IT A REAL SPACE?
	JRNZ	LET_FOUND
SPACE_FOUND:
	ADDI	BYTE_SIZE,A1
	DSJS	A2,CHECK_NEXT
	CLR	A2			;SET Z BIT ON FALL THROUGH

LET_FOUND:
	MMFM	SP,A0,A1,A2
	RETS

CHECK_SCORE:
	MMTM	SP,A1,A3,A9,A10
	MOVE	A0,A3			;STASH SCORE IN A3
	CALLR	FIND_TABLE_LEVEL	;SEE WHERE WE LAND IN THIS TABLE
	JRZ	ANSWER_IN_A0		;ZERO.....GUY DIDN'T MAKE IT
	MOVE	*A8(TB_VISIBLE),A1,W	;GET THE NUMBER "ENTERED"
	CMP	A1,A0			;A0 MUST BE LESS OR EQUAL
	JRLO	ANSWER_IN_A0		;NOT LAST ENTRY...RETURN SUCCESS
	JRHI	DIDNT_MAKE_HSTD
	CMP	A2,A3			;HI MUST BE HIGHER THAN BUDDY
	JRHI	ANSWER_IN_A0
DIDNT_MAKE_HSTD:
	CLR	A0			;RETURN FAILURE
ANSWER_IN_A0:
	MOVE	A0,A0			;SET EQ BIT ACCORDINGLY
	MMFM	SP,A1,A3,A9,A10
	RETS

ADD_ENTRY:
	MMTM	SP,A0,A1,A2,A3,A4,A7,A9,A10
	CALLR	ROM_PTRS		;SETUP FOR THIS TABLE
	MOVE	A0,A4			;STASH THE SCORE A SEC.
	CLR	A2			;DONT WORRY ABOUT OTHER GUY AT THIS POINT
	CALLR	CHECK_SCORE		;DOES THE REQUEST MAKE IT?
	SETC				;ANTICIPATE FAILURE
	JRZ	DIDNT_MAKE_IT		;DON'T KNOW WHY I GOT THESE INITS.
	MOVE	A10,A3			;LAST GUY IN TABLE IS DESTINATION

COPY_DOWN_LOOP:
	MOVE	A3,A2			;GUY BEFORE HIM IS SOURCE
	DEC	A2			;A2 NOW HAS SOURCE
	CMP	A0,A2			;IS SOURCE LOWER THAN OUR SLOT?
	JRLO	COPY_DONE		;IT IS...DON'T MOVE HIM.

	CALLR	COPY_ENTRY		;COPY A2 ENTRY TO A3
	DEC	A3			;MOVE DOWN TO ONE BEFORE
	JRUC	COPY_DOWN_LOOP

COPY_DONE:
	CALLR	PUT_SCORE_FOR_ENTRY	;SCORE IN A4 WRITTEN TO ENTRY A0
	CALLR	PT_ENTRY		;GET ENTRY POINTER IN A7
	ADDI	HS_INITS,A7		;POINT AT FIRST INITIAL
	MOVI	NUM_INITS,A2		;THIS IS NUMBER OF INITIALS
	MMTM	SP,A0			;SAVE A0

INIT_COPY_LOOP:
	MOVB	*A1,A0			;GET AN INITIAL
	JRNZ	NOT_BLANK
	MOVI	SPACE,A0		;REPLACE BLANKS WITH SPACES
NOT_BLANK:
	CALLR	WC_BYTEI		;WRITE THE BYTE AND INCREMENT
	ADDI	BYTE_SIZE,A1		;A1 TO NEXT BYTE PLEASE
	DSJ	A2,INIT_COPY_LOOP

	MMFM	SP,A0			;GET BACK ENTRY NUMBER
	CALLR	FORM_HS_CKSUM_AND_STORE	;FOR CHECKSUM FOR THIS ENTRY AND STORE!
	CLRC				;RETURN SUCCESS!

DIDNT_MAKE_IT
	MMFM	SP,A0,A1,A2,A3,A4,A7,A9,A10
	RETS

FIND_TABLE_LEVEL
	MMTM	SP,A1,A2,A3
	CALLR	ROM_PTRS		;SETUP FOR THIS TABLE
	CALLR	VAL_TAB 		;FIX THE TABLE IN CASE ITS BROKEN.
	JRC	FTL_FAIL		;CAN'T VALIDATE..SAY SCORE DIDN'T MAKE IT

	MOVE	A0,A2			;KEEP SCORE IN A2
	MOVK	1,A0			;START AT 1 AND WORK UP.

CHECK_NEXT_SCORE:
	CALLR	GET_HSCR		;FETCH A0 ENTRY'S SCORE IN A1
	CMP	A1,A2			;HOW DO WE FARE AGAINST A1?
	JRHI	FOUND_THE_SPOT		;WE FOUND THE SPOT
	INC	A0			;KEEP MOVING DOWN TILL WE FIT
	CMP	A10,A0			;ARE WE LOOKING AT THE LAST ONE?
	JRLS	CHECK_NEXT_SCORE

FTL_FAIL:
	CLR	A0			;WE'RE NOT HIGH ENOUGH RETURN FAILURE

FOUND_THE_SPOT:
	MOVE	A0,A0			;MAKE SURE YOU SET THE FLAGS
	MMFM	SP,A1,A2,A3
	RETS

GET_HSCR
	MMTM	SP,A7,A0
	CALLR	PT_ENTRY		;POINT A7 AT ENTRY
	ADDI	HS_SCORE,A7		;INDEX SCORE PART.
	CALLR	RC_LONG 		;FETCH THE LONG WORD INTO A0
	MOVE	A0,A1			;MOVE TO A1
	MMFM	SP,A7,A0
	RETS

PUT_SCORE_FOR_ENTRY
	MMTM	SP,A7,A0
	CALLR	PT_ENTRY		;POINT A7 AT ENTRY
	ADDI	HS_SCORE,A7		;INDEX SCORE PART.
	MOVE	A4,A0			;MOVE SCORE TO A0
	CALLR	WC_LONG 		;WRITE OUT THE LONG WORD
	MMFM	SP,A7,A0
	RETS

FORM_HS_CKSUM:
	MMTM	SP,A0,A4,A6,A7
	CALLR	PT_ENTRY		;A7 = POINTER TO CURRENT ENTRY
	MMTM	SP,A7			;SAVE POINTER TO ENTRY
	MOVI	HS_BYTES_TO_CHECK,A4	;COUNT DOWN THE BYTES
	CLR	A1			;KEEP SUM IN A1
ADD_A_BYTE:
	CALLR	RC_BYTEI		;GET A BYTE INTO A0
	ADD	A0,A1			;ADD TO SUM
	DSJ	A4,ADD_A_BYTE		;ONE MORE ADDED
	NOT	A1			;CHECKSUM IS NOW IN LOW BYTE
	ANDI	BYTE_MASK,A1		;MASK SO ITS COOL
	MMFM	SP,A7			;GET POINTER BACK
	ADDI	HS_CKBYTE,A7		;POINT AT CHECKBYTE
	CALLR	RC_BYTE 		;READ IN THE BYTE
	CMP	A0,A1			;COMPARE WHAT'S THERE TO WHAT WE GOT
	MMFM	SP,A0,A4,A6,A7		;Z BIT RETURNS COMPARE
	RETS				;A1 RETURNS CKSUM

FORM_HS_CKSUM_AND_STORE:
	MMTM	SP,A0,A7
	CALLR	FORM_HS_CKSUM		;GET THE CKSUM IN A1, POINTER IN A7
	CALLR	PT_ENTRY		;POINT AT THE VALUE
	ADDI	HS_CKBYTE,A7		;POINT AT CHECKBYTE
	MOVE	A1,A0			;GET CHECKBYTE TO A0
	CALLR	WC_BYTE 		;WRITE OUT THE BYTE
	MMFM	SP,A0,A7
	RETS

PT_ENTRY:
	CMP	A10,A0			;A10 IS MAX VALUE
	JRLS	POINTER_IN_RANGE

	.IF DEBUG
	JRUC	$			;HANG IN DEVELOPMENT
	.ENDIF

	MOVE	A9,A7			;RETURN ZERO OFFSET IN FIELD
	RETS

POINTER_IN_RANGE:
	MOVI	HS_SIZE,A7		;SIZE OF ENTRY
	MPYU	A0,A7			;OFFSET OF ENTRY
	ADD	A9,A7			;ADD IN THE BASE
	RETS

ROM_PTRS:
	MMTM	SP,A0,A1		;SCRATCH REGGIES
	MOVE	*A8(TB_POINTER),A9,L	;GET CMOS POINTER
	MOVE	*A8(TB_COUNT),A10,W	;GET NUMBER OF ENTRIES
	MOVE	*A8(TB_PAGE_BITS),A1	;GET OUR CMOS PAGE BITS

	CALLR	SET_PAGE

	MMFM	SP,A0,A1		;SCRATCH REGGIES
	RETS

SET_PAGE
	MMTM	SP,A0,A1
	ANDI	CMOS_PAGE_SELECT_BITS,A1	;KILL SIGN EXTEND..SAVE BITS
	PUSHST					;SAVE INTERRUPT STATUS
	DINT					;STOP INTERRUPTS
	MOVE	@SYSCOPY,A0,W			;GET THE RAM COPY
	ANDNI	CMOS_PAGE_SELECT_BITS,A0	;REMOVE THE CURRENT PAGE SELECT
	OR	A1,A0				;ADD IN OUR BITS
	MOVE	A0,@SYSCOPY,W			;PUT THEM BACK IN THE RAM COPY
	POPST					;OK TO RE-START INTS
	MMFM	SP,A0,A1
	RETS

INIT_TAB
 .if 0
	MMTM	SP,A8,A0

	MOVI	TOD_TAB,A8
	CALLR	INIT_TB 	;RESET TODAYS TABLE

	CALLR	GET_HSC 	;CHECK THE HIGH SCORE RESET COUNTER
	JRNZ	INIT_TAB1	;NOT ZERO...NO MORE ACTIVITY
	MOVI	ADJHSRES,A0
	CALLA	GET_ADJ 	;GET THE ADJUSTED VALUE
	JRZ	INIT_TAB1	;ITS TURNED OFF...NO ACTION.

	MOVI	ALL_TAB,A8	;RESET THE ALL TIME TABLE
	CALLR	INIT_TB 	;INIT THE ALL TIME TABLE

	CALLR	INIT_HSR	;RESET THE COUNTER TO ADJUSTED VALUE

INIT_TAB1
	MMFM	SP,A8,A0
 .endif
	RETS

INIT_TB:
 .if 0
	MMTM	SP,A5,A6,A7,A0
	CALLR	ROM_PTRS		;STUFF TABLE DATA
	MOVE	*A8(TB_FACTORY),A6,L ;GET THE FACTORY TABLE
	MOVE	A10,A5			;NUMBER OF VALID ENTRIES
	INC	A5			;1 MORE TO HOLD ZERO ENTRY
	MOVI	HS_SIZE_IN_BYTES,A1	;SIZE OF 1 ENTRY
	MPYU	A1,A5			;A7 HAS NUMBER OF WORDS TO MOVE
	MOVE	A9,A7			;CMOS POINTER IN A7

INIT_TB_1:
	MOVB	*A6,A0			;GET A BYTE FROM ROM
	ADDI	BYTE_SIZE,A6		;KICK ROM POINTER
	CALLR	WC_BYTEI		;WRITE THE BYTE AND INCREMENT
	DSJS	A5,INIT_TB_1		;UNTIL THEY'RE ALL THERE.

	MOVE	A10,A0			;POINT AT LAST ENTRY
INIT_TB_2:
	CALLR	FORM_HS_CKSUM_AND_STORE	;SET ITS CHECKSUM
	DEC	A0			;MOVE DOWN
	JRNN	INIT_TB_2		;SET EACH ONE INCLUDING ZERO
	MMFM	SP,A5,A6,A7,A0
 .endif
	RETS

COPY_ENTRY:
	MMTM	SP,A0,A4,A5,A6,A7
	MOVI	HS_SIZE_IN_BYTES,A4	;ENTRY SIZE IN BYTES
	MOVE	A2,A0			;FIRST POINT FOR A0
	CALLR	PT_ENTRY	
	MOVE	A7,A6			;A6 = SOURCE POINTER
	MOVE	A3,A0
	CALLR	PT_ENTRY		;A5 = DESTINATION
	MOVE	A7,A5
COPY_LOOP:
	MOVE	A6,A7			;SOURCE IN CMOS REGGIE
	CALLR	RC_BYTEI		;FETCH A WORD
	MOVE	A7,A6
	MOVE	A5,A7			;DESTINATION
	CALLR	WC_BYTEI		;WRITE IT
	MOVE	A7,A5			;BACK TO DEST REGGIE
	DSJ	A4,COPY_LOOP		;UNTIL ALL WORDS ARE COPIED
	MMFM	SP,A0,A4,A5,A6,A7
	RETS

VAL_TAB
	CLR	A2		;indicate first call in
	CALLR	DO_VALIDATE	;validate
	RETS

DO_VALIDATE
	MMTM	SP,A0,A1,A3,A4,A5,A6,A7
	CALLR	ROM_PTRS		;SETUP FOR TABLE
	MOVI	1,A0			;ITERATE THROUGH THE ENTRIES
	CLR	A1			;COUNT ERRORS

CHECK_A0_ENTRY:
	CALLR	CHECK_ENTRY		;IS THE ENTRY OK?
	JRNC	VT_1			;YEP.

	CALLR	REMOVE_ENTRY		;REMOVE THIS ENTRY
	INC	A1
	MOVE	*A8(TB_ERROR_COUNT),A3	;GET THRESHOLD
	CMP	A3,A1			;ARE WE THERE?
	JRLO	CHECK_A0_ENTRY		;NOPE...CHECK MOVE UP ENTRY AT A0
	MOVE	A2,A2			;IS THIS RECURSIVE CHECK AFTER INIT?
	JRNZ	CANT_VALIDATE		;THEN RETURN FAILURE

	CALLR	INIT_TB 		;INIT THIS TABLE PLEASE
	MOVK	1,A2			;INDICATE RECURSIVE CALL
	CALLR	DO_VALIDATE		;IS IT ALRIGHT NOW?
	MMFM	SP,A0,A1,A3,A4,A5,A6,A7
	RETS
VT_1:	
	INC	A0			;KICK IT
	CMP	A10,A0			;STILL IN TABLE?
	JRLS	CHECK_A0_ENTRY		;YEP....CHECK THIS ENTRY

	CLRC				;RETURN VALID!
	MMFM	SP,A0,A1,A3,A4,A5,A6,A7
	RETS

CANT_VALIDATE:
	SETC				;RETURN FAILURE!
	MMFM	SP,A0,A1,A3,A4,A5,A6,A7
	RETS

CHECK_ENTRY
	MMTM	SP,A0,A1,A2,A3,A7
	CALLR	FORM_HS_CKSUM		;CHECK OUT CKSUM FIRST
	JRNZ	CHECK_FAIL		;BAD CHECKSUM....ITS BAD
	CALLR	GET_HSCR		;SCORE IN A1
	MOVE	A1,A3			;SAVE COPY OF SCORE

CHECK_DIGIT:
	MOVE	A1,A2			;COPY FOR NEXT NIBBLE
	ANDI	0FH,A2			;MASK THE NIBBLE
	CMPI	9,A2
	JRHI	CHECK_FAIL		;NIBBLE TOO HIGH
	SRL	4,A1			;SHIFT DOWN TO NEXT NIBBLE
	JRNZ	CHECK_DIGIT

	DEC	A0			;MAKE SURE WE ARE LOWER THAN PREVIOUS SCORE!
	JREQ	FIRST_ENT		;WE'RE THE 1ST IN THE TABLE

	CALLR	GET_HSCR		;GET THE SCORE FOR THE GUY BEFORE US
	CMP	A1,A3			;OURS MUST BE LOWER OR SAME
	JRHI	CHECK_FAIL		;OURS IS BIGGER....REMOVE US

FIRST_ENT:
	INC	A0			;RESTORE THE ENTRY NUMBER
	CALLR	PT_ENTRY		;POINT A7 AT ENTRY
	ADDI	HS_INITS,A7		;POINT AT FIRST INITIAL
	MOVI	NUM_INITS,A2		;THIS IS NUMBER OF INITIALS

NEXT_LETTER:
	CALLR	RC_BYTEI		;FETCH A BYTE

	CALLR	VERIFY_LETTER		;SEE IF ITS VALID.
	JRC	CHECK_FAIL		;NOT A LETTER...BYTE

	DSJ	A2,NEXT_LETTER

	CLRC				;RETURN PASS
	MMFM	SP,A0,A1,A2,A3,A7
	RETS

CHECK_FAIL:
	SETC
	MMFM	SP,A0,A1,A2,A3,A7
	RETS



VERIFY_LETTER:
	ANDI	BYTE_MASK,A0		;KEEP JUST THE BYTE

	CMPI	'!',A0			;SPACE?
	JREQ	VERIFY_PASS		;ITS OK.

	CMPI	'%',A0			;SPACE?
	JREQ	VERIFY_PASS		;ITS OK.

	CMPI	'?',A0			;SPACE?
	JREQ	VERIFY_PASS		;ITS OK.

	CMPI	SPACE,A0		;SPACE?
	JREQ	VERIFY_PASS		;ITS OK.

	CMPI	LET_A,A0		;BETWEEN A-Z?
	JRLO	VERIFY_FAIL

	CMPI	LET_Z,A0
	JRHI	VERIFY_FAIL

VERIFY_PASS:
	CLRC
	RETS

VERIFY_FAIL:
	SETC
	RETS

REMOVE_ENTRY:
	MMTM	SP,A0,A1,A2,A6,A7
	MOVE	A0,A3			;THIS IS DEST
	MOVE	A3,A2			;SOURCE IS 1 BELOW

BUBBLE_ANOTHER:
	INC	A2			;NOW WE'RE SET FOR A COPY...

	CMP	A10,A2			;IS SOURCE OUT OF RANGE?
	JRHI	BUBBLE_DONE		;YEP....WE'RE AT THE BOTTOM (A3)

	CALLR	COPY_ENTRY
	INC	A3
	JRUC	BUBBLE_ANOTHER

BUBBLE_DONE:
	MOVE	A3,A0			;THIS IS BOTTOM OF TABLE
	CALLR	PT_ENTRY		;A7 POINTS AT CMOS BLOCK

	MOVE	*A8(TB_FACTORY),A6,L	;GET FACTORY TABLE
	MOVI	HS_ROM_SIZE,A1		;SIZE OF ENTRY
	MPYU	A10,A1			;TIMES NUMBER OF VALID ENTRIES..POINTS AT LAST.
	ADD	A1,A6			;NOW WE POINT AT END OF ROM TABLE
	MOVI	HS_SIZE_IN_BYTES,A2	;SIZE OF ENTRY

REPLACE_LOOP:
	MOVB	*A6,A0			;MOVE A ROM BYTE TO A0
	ADDI	BYTE_SIZE,A6
	CALLR	WC_BYTEI		;WRITE THE WORD AND INCREMENT
	DSJ	A2,REPLACE_LOOP		;UNTIL THEY'RE ALL THERE.

	MOVE	A10,A0			;POINT AT "LAST" ENTRY
	CALLR	FORM_HS_CKSUM_AND_STORE	;STORE THE CHECKBYTE
	MMFM	SP,A0,A1,A2,A6,A7	;AND RETURN
	RETS




RC_BYTE
	.if	TUNIT

	move	@SYSCOPY,a0
	sll	32-8,a0
	srl	32-2,a0
	sll	15,a0		;Page offset
	add	a7,a0
	movb	*a0,a0
	sll	32-8,a0
	srl	32-8,a0
	rets

	.else

	movb	*a7,a0
	sll	32-8,a0
	srl	32-8,a0
	rets

	.endif

WC_BYTE
	.IF	YUNIT
	MOVE	A1,-*SP,L
	MOVI	0200H,A1	;UNLOCK THE CMOS
	MOVE	A1,@SECCHIP
	.ENDIF

	.if	TUNIT

	move	@SYSCOPY,a1
	sll	32-8,a1
	srl	32-2,a1
	sll	15,a1		;Page offset
	add	a7,a1
	move	a0,@CMOSWE
	movb	a0,*a1

	.else

	movb	a0,*a7		;Write byte

	.endif

	.IF	YUNIT
	MOVI	0300H,A1	;LOCK THE CMOS
	MOVE	A1,@SECCHIP
	MMFM	SP,A1
	.ENDIF

	rets

RC_BYTEI:
	CALLR	RC_BYTE
	ADDI	C_BYTE_SIZE,A7	;WORDS SEPARATE CMOS BYTES.
	MOVE	A0,A0		;RETURN FLAGS ACCORDINGLY
	RETS

RC_WORD:
	MMTM	SP,A1,A7	;USE A1 TO COMBINE BYTES
	CALLR	RC_BYTEI	;GET A BYTE
	MOVE	A0,A1		;SAVE IN A1
	ANDI	BYTE_MASK,A1	;MASK ONLY BYTE
	SLL	8,A1		;SHIFT TO HIGH BYTE
	CALLR	RC_BYTE		;GET THE 2ND BYTE
	ANDI	BYTE_MASK,A0
	OR	A1,A0		;A0 HAS THE WORD
	MMFM	SP,A1,A7	
	RETS

RC_WORDI:
	CALLR	RC_WORD
	ADDI	C_WORD_SIZE,A7	;LONG SEPARATE CMOS WORDS.
	MOVE	A0,A0		;RETURN FLAGS ACCORDINGLY
	RETS

RC_LONG:
	MMTM	SP,A1,A7	;USE A1 TO COMBINE BYTES
	CALLR	RC_WORDI	;GET A WORD
	MOVE	A0,A1		;SAVE IN A1
	ANDI	WORD_MASK,A1	;MASK ONLY WORD
	SLL	16,A1		;SHIFT TO HIGH WORD
	CALLR	RC_WORD		;GET THE 2ND WORD
	ANDI	WORD_MASK,A0
	OR	A1,A0		;A0 HAS THE LONG WORD
	MMFM	SP,A1,A7	
	RETS

RC_LONGI:
	CALLR	RC_LONG
	ADDI	C_LONG_SIZE,A7	;DOUBLE THE DISTANCE FOR BRAIN DAMIJ
	MOVE	A0,A0		;RETURN FLAGS ACCORDINGLY
	RETS

WC_BYTEI:
	CALLR	WC_BYTE
	ADDI	C_BYTE_SIZE,A7
	RETS

WC_WORD:
	MMTM	SP,A0,A1,A7
	MOVE	A0,A1		;MAKE COPY OF WORD
	SRL	8,A0		;GET HIGH BYTE IN A0
	CALLR	WC_BYTEI	;WRITE THE HIGH BYTE
	MOVE	A1,A0		;NOW GET THE LOW BYTE BACK
	CALLR	WC_BYTE ;WRITE IT
	MMFM	SP,A0,A1,A7	;AND RESTORE ALL WE TOUCHED
	RETS

WC_WORDI:
	CALLR	WC_WORD
	ADDI	C_WORD_SIZE,A7
	RETS

WC_LONG:
	MMTM	SP,A0,A1,A7
	MOVE	A0,A1		;MAKE COPY OF LONG
	SRL	16,A0		;GET HIGH WORD IN A0
	CALLR	WC_WORDI	;WRITE THE HIGH WORD
	MOVE	A1,A0		;NOW GET THE LOW WORD BACK
	CALLR	WC_WORD ;WRITE IT
	MMFM	SP,A0,A1,A7	;AND RESTORE ALL WE TOUCHED
	RETS

WC_LONGI:
	CALLR	WC_LONG
	ADDI	C_LONG_SIZE,A7
	RETS


TB_POINTER	 EQU	 0			;LONG-POINTER TO BEGINNING OF TABLE
TB_COUNT	 EQU	 TB_POINTER+LONG_SIZE	;WORD....# IN THE TABLE.
TB_VISIBLE	 EQU	 TB_COUNT+WORD_SIZE	;WORD....NUMBER DISPLAYED
TB_PAGE_BITS	 EQU	 TB_VISIBLE+WORD_SIZE	;WORD....STATUS WORD FOR CMOS PAGE
TB_FACTORY	 EQU	 TB_PAGE_BITS+WORD_SIZE	;LONG....ROM STARTUP TABLE
TB_ERROR_COUNT	 EQU	 TB_FACTORY+LONG_SIZE	;WORD....NUM ERRORS TO RE-INIT


SCRM	.MACRO	a,b
	.byte	:a:/01000000H,:a:/010000H&0ffH,:a:/0100H&0ffH,:a:&0ffH
	.byte	":b:",0
	.ENDM


ALL_TIME_ROM_TABLE
	SCRM	022122145H,"EPJ"		;****ZERO ENTRY...NOT SEEN!
ROM_ENTRY_SIZE	EQU	$-ALL_TIME_ROM_TABLE
	SCRM	0484692H,"MJT"
	SCRM	0434010H,"SL!"
	SCRM	0366892H,"JON"
	SCRM	0296096H,"SYD"
	SCRM	0265237H,"HEY"
	SCRM	0215782H,"EJB"
	SCRM	0182074H,"DRJ"
	SCRM	0146892H,"PJS"
	SCRM	0130523H,"GNP"
	SCRM	0118913H,"TIM"
ALL_TIME_ENTRIES	EQU	($-ALL_TIME_ROM_TABLE)/ROM_ENTRY_SIZE

TODAYS_ROM_TABLE
	SCRM	022122145H,"EPJ"		;****ZERO ENTRY...NOT SEEN!
	SCRM	0111111H,"SL!"
	SCRM	094477H,"EPJ"
	SCRM	080486H,"LED"
	SCRM	070882H,"DAN"
	SCRM	068040H,"DJT"
	SCRM	059104H,"JPW"
	SCRM	040450H,"NED"
	SCRM	038780H,"MJT"
	SCRM	028088H,"BUY"
	SCRM	016502H,"WMS"

TODAYS_ENTRIES	EQU	($-TODAYS_ROM_TABLE)/ROM_ENTRY_SIZE

	 .END


